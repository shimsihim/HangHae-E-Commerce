# e-Commerce 주문 서비스 요구사항 정의서

## 목차
1. [문서 개요](#문서-개요)
2. [기능적 요구사항](#기능적-요구사항)
   - [유저](#유저)
   - [상품](#상품)
   - [쿠폰 관리](#쿠폰-관리)
   - [재고 관리](#재고-관리)
   - [주문 및 결제](#주문-및-결제)
3. [비기능적 요구사항](#비기능적-요구사항)
4. [제약사항 및 가정](#제약사항-및-가정)

---

## 문서 개요

본 문서는 e-Commerce 주문 서비스의 기능적/비기능적 요구사항을 정의합니다.

### 문서 목적
- 프로젝트 범위 및 기능 명확화
- 동시성 제어가 필요한 기능 식별
- 개발 단계에서의 구현 가이드라인 제공

### 주요 특징
- 동시성 제어가 필수적인 e-Commerce 핵심 기능에 집중
- 간소화된 기능 범위로 기술 학습에 최적화
- 실무에서 발생하는 대용량 트래픽 환경을 가정

---

## 기능적 요구사항

#### 포인트 관리 (🔥 동시성 제어 필수)

| 요구사항명 | 기능명    | 상세설명                                                                                 | 필수 데이터        | 선택 데이터 |
|:-----:|:------:|:------------------------------------------------------------------------------------:|:--------------:|:------:|
| 포인트   | 충전     | 포인트를 충전할 수 있다. (1회 충전 금액은 최대 50만원을 넘을 수 없다.) (충전 후 총 금액은 1,000,000,000을 넘을 수 없다.) | 유저 ID, 충전량 (>0) |        |
| 포인트   | 사용     | 포인트를 사용할 수 있다. (사용 금액은 보유 금액을 넘을 수 없다.)                                              | 유저 ID, 사용량 (>0) |        |
| 포인트   | 동시성 제어 | 같은 사용자에 대해 동시에 여러 건의 충전 및 사용 요청이 들어와도 정확하게 반영되어야 한다.                                 |                |        |
| 포인트   | 기록     | 포인트 사용 및 충전 시 해당 내역은 모두 기록되어야 한다.                                                   |                |        |
| 포인트   | 조회     | 사용자는 자신의 잔여 포인트를 확인할 수 있어야 한다.                                                      | 유저 ID          |        |
| 포인트   | 이력 조회  | 사용자는 자신의 포인트 이력을 조회할 수 있어야 한다.                                                      | 유저 ID          |        |

**상세 설명**
- 포인트 충전/사용 시 user_point 테이블의 version 필드를 활용한 낙관적 락 적용
- 모든 포인트 변동은 point_history 테이블에 기록 (감사 추적)
- 포인트 이력 조회 시 최신순으로 정렬하여 반환

**검증 규칙**
- 충전: 1회 최대 500,000원, 총 잔액 최대 1,000,000,000원
- 사용: 잔액 범위 내에서만 사용 가능
- 음수 값 입력 불가

### 상품

| 요구사항명 | 기능명      |                                             상세설명                                             | 필수 데이터 | 선택 데이터                                                    |
|:-----:|:--------:|:--------------------------------------------------------------------------------------------:|:------:|:---------------------------------------------------------:|
| 상품    | 상품 목록 조회 | 사용자는 상품 목록을 조회할 수 있다. (금액순, 최신순, 인기순 등의 정렬이 가능하다)<br>인기순 정렬 시 최근 N일(기본 7일) 내 판매량을 기준으로 정렬한다. |        | 정렬 조건: 금액 오름차순, 금액 내림차순, 최신순, 인기순<br>인기순 조회 기간: N일(기본 3일) |
| 상품    | 상품 상세 조회 |                     사용자는 상품 목록에서 특정 상품 클릭 시 해당 상품의 상세 설명, 옵션을 조회할 수 있다.                      | 상품 ID  |                                                           |

**상세 설명**

**상품 목록 조회**
- 페이징 처리 지원 (기본 20개씩)
- 정렬 옵션:
  - 최신순: created_at DESC
  - 가격 오름차순: base_price ASC
  - 가격 내림차순: base_price DESC
  - 인기순: product_statistics 테이블 기반 (기본 7일, 조정 가능)
- 인기순 조회 시 캐싱 적용 (Redis)

**상품 상세 조회**
- 상품 기본 정보 (이름, 설명, 기본 가격, 이미지)
- 상품 옵션 목록 (옵션명, 가격, 재고 수량)
- 품절 여부 표시


### 쿠폰 관리 (🔥 동시성 제어 필수)

| 요구사항명 | 기능명       | 상세설명                                                                         | 필수 데이터      | 선택 데이터 |
|:-----:|:---------:|:----------------------------------------------------------------------------:|:------------:|:------:|
| 쿠폰    | 쿠폰 발급     | 시스템은 선착순으로 쿠폰을 발급해야 하며, 발급 가능 수량 초과 시 발급에 실패해야 한다. (1인당 발급 제한)          | 유저 ID, 쿠폰 ID |        |
| 쿠폰    | 동시성 제어    | 대량의 쿠폰 발급 요청이 동시에 발생해도 발급 가능 수량을 초과하지 않아야 한다.                                |              |        |
| 쿠폰    | 쿠폰 조회     | 사용자는 자신이 발급받은 쿠폰 목록을 조회할 수 있다.                                                | 유저 ID        |        |
| 쿠폰    | 쿠폰 사용     | 사용자는 자신이 발급받은 쿠폰을 주문 시 사용할 수 있다. 이때 할인율에 따라 금액을 할인한다.                        | 유저 쿠폰 ID    |        |
| 쿠폰    | 쿠폰 유효성 검증 | 시스템은 쿠폰 발급 및 사용 시 쿠폰의 유효성을 검증해야 한다. (유효기한, 사용여부, 소유여부, 중복 발급 여부)          |              |        |

**상세 설명**

**쿠폰 발급 (선착순) - Redis 분산 락 방식 🔥 권장**

선착순 쿠폰은 **높은 동시성 + 빠른 응답 + 정확한 수량 제어**가 필요하므로 Redis 기반 구현이 최적입니다.

#### 구현 방식

**1. Redis 데이터 구조**
```
- coupon:{couponId}:remaining    → 남은 발급 가능 수량 (INT)
- coupon:{couponId}:issued:{userId} → 사용자별 발급 여부 (SET)
```

**2. 발급 프로세스 (Lua 스크립트로 원자적 처리)**
```lua
-- 1. 남은 수량 확인
local remaining = redis.call('GET', 'coupon:' .. couponId .. ':remaining')
-- 2. 사용자 발급 이력 확인
local issued = redis.call('SISMEMBER', 'coupon:' .. couponId .. ':issued', userId)
-- 3. 조건 충족 시 수량 차감 및 발급 기록
if remaining > 0 and issued == 0 then
    redis.call('DECR', 'coupon:' .. couponId .. ':remaining')
    redis.call('SADD', 'coupon:' .. couponId .. ':issued', userId)
    return 1  -- 성공
end
return 0  -- 실패
```

**3. 전체 플로우**
1. 사용자 요청 → API 서버
2. Redis Lua 스크립트 실행 (원자적 연산)
3. 발급 성공 시:
   - 즉시 성공 응답 반환
   - Kafka 이벤트 발행: `CouponIssuedEvent`
   - 컨슈머가 비동기로 DB 기록 (user_coupons, coupons.issued_quantity)
4. 발급 실패 시: 실패 응답 (수량 부족 또는 이미 발급)

**4. 장점**
- ✅ 빠른 응답: Redis 메모리 연산 (< 10ms)
- ✅ 정확한 수량 제어: Lua 스크립트의 원자적 연산
- ✅ 높은 TPS: 10,000+ TPS 처리 가능
- ✅ 확장성: 여러 서버에서 동일한 Redis 접근


> **왜 낙관적 락은 안되나?**
> 10,000명이 100개 쿠폰 요청 → 100명만 성공, 9,900명 실패 → 재시도 폭증 → 서버 부하 → UX 악화

**쿠폰 유효성 검증**
- 유효기간 체크: valid_from <= 현재시간 <= valid_until
- 사용 여부 체크: user_coupons.status == 'ISSUED'
- 소유 여부 체크: user_coupons.user_id == 요청 유저
- 중복 발급 체크: 동일 쿠폰 발급 이력 확인
- 최소 주문 금액 체크: 주문 금액 >= min_order_value

**쿠폰 할인 계산**
- PERCENTAGE: 주문 금액 * (discount_value / 100)
- FIXED_AMOUNT: discount_value 원 할인

### 재고 관리 (🔥 동시성 제어 필수)

| 요구사항명 | 기능명    | 상세설명                             | 필수 데이터       | 선택 데이터 |
|:-----:|:------:|:--------------------------------:|:-------------:|:------:|
| 재고    | 재고 조회  | 사용자는 상품의 실시간 재고 수량을 확인할 수 있어야 한다.    | 상품 옵션 ID     |        |
| 재고    | 재고 차감  | 결제 완료 시 재고를 차감해야 한다.               | 상품 옵션 ID, 수량 |        |
| 재고    | 재고 복구  | 주문 취소 및 결제 실패 시 재고를 복구해야 한다.       | 상품 옵션 ID, 수량 |        |
| 재고    | 동시성 제어 | 동시에 발생하는 주문에 대해 재고 차감이 정확하게 처리되어야 한다. |               |        |

**상세 설명**

**재고 조회**
- product_options 테이블의 quantity 필드 조회
- 재고가 0인 경우 "품절" 표시

**재고 차감 (동시성 제어 핵심)**
- 비관적 락(Pessimistic Lock) 적용: `SELECT ... FOR UPDATE`
- 또는 Redis 분산 락을 활용한 재고 차감
- 재고 부족 시 주문 실패 처리
- 재고 차감 순서:
  1. 재고 조회 및 락 획득
  2. 재고 충분 여부 확인
  3. 재고 차감 (quantity = quantity - 주문수량)
  4. 트랜잭션 커밋 및 락 해제

**재고 복구**
- 주문 취소 또는 결제 실패 시 차감된 재고 복원
- 복구 시에도 동시성 제어 적용
- 재고 이력 추적 (선택사항)

**동시성 제어 전략**
1. **비관적 락**: 높은 경합이 예상되는 경우 적용
2. **Redis 분산 락**: 여러 서버에서 동시 접근 시 락 공유
3. **재고 예약 패턴**: 주문 생성 시 재고 예약, 결제 완료 시 확정


### 주문 및 결제

| 요구사항명 | 기능명         | 상세설명                                                  | 필수 데이터                  | 선택 데이터  |
|:-----:|:-----------:|:-----------------------------------------------------:|:------------------------:|:-------:|
| 주문    | 주문 생성       | 사용자는 주문을 생성할 수 있다. (재고 검증 포함, 주문 상태: PENDING)        | 유저 ID, 상품 옵션들 및 각각의 수량 |         |
| 결제    | 결제          | 사용자는 자신의 포인트를 사용하여 주문을 결제 완료할 수 있다. (주문 상태: PAID) | 유저 ID, 주문 ID            | 유저 쿠폰 ID |
| 결제    | 결제 실패 처리    | 포인트 부족 또는 재고 부족 시 결제가 실패하며 주문 상태는 PENDING으로 유지된다.    |                          |         |
| 주문    | 주문 내역 조회    | 사용자는 주문 내역을 조회할 수 있다.                                 | 유저 ID                    |         |
| 주문    | 주문 상세 내역 조회 | 사용자는 주문 상세 내역을 조회할 수 있다.                              | 유저 ID, 주문 ID            |         |

**상세 설명**

**주문 생성**
- 직접 구매를 통한 주문 생성
- 재고 검증: 모든 상품 옵션의 재고가 충분한지 확인
- 주문 금액 계산: 각 옵션의 단가 × 수량의 합계
- 초기 주문 상태: PENDING
- orders 테이블과 order_items 테이블에 데이터 저장

**결제 처리 (트랜잭션 필수)**
결제 프로세스는 다음 단계를 하나의 트랜잭션으로 처리:
1. **주문 조회**: 주문 상태가 PENDING인지 확인
2. **쿠폰 검증 및 적용**: 선택사항, 유효성 검증 후 할인 금액 계산
3. **포인트 차감**: user_point.balance에서 최종 결제 금액 차감 (낙관적 락)
4. **재고 차감**: product_options.quantity 차감 (비관적 락 또는 분산 락)
5. **주문 상태 변경**: orders.status를 PAID로 변경, paid_at 기록
6. **포인트 이력 기록**: point_history에 사용 내역 추가
7. **쿠폰 상태 변경**: user_coupons.status를 USED로 변경

**결제 금액 계산**
```
total_amount = Σ(unit_price × quantity)
discount_amount = 쿠폰 할인 금액
use_point_amount = 사용 포인트 (선택사항, 미구현)
final_amount = total_amount - discount_amount - use_point_amount
```

**결제 실패 처리**
- 포인트 부족: `balance < final_amount`
- 재고 부족: 결제 시점에 재고가 변경된 경우
- 쿠폰 무효: 이미 사용되었거나 만료된 경우
- 실패 시 모든 변경사항 롤백 (트랜잭션)

**주문 내역 조회**
- 사용자별 주문 목록 조회 (최신순)
- 페이징 처리 지원
- 주문 상태별 필터링 가능

**주문 상세 조회**
- 주문 기본 정보 (주문 번호, 주문 일시, 상태, 금액)
- 주문 항목 목록 (상품명, 옵션, 수량, 단가, 소계)
- 쿠폰 정보 (사용한 경우)
- 포인트 사용 내역

---

## 비기능적 요구사항

### 1. 성능 (Performance)

| 항목           | 요구사항                               | 목표치            |
|--------------|------------------------------------|--------------------|
| 응답 시간        | 일반 조회 API의 평균 응답 시간               | 200ms 이내          |
| 응답 시간        | 주문/결제 API의 평균 응답 시간               | 1초 이내            |
| 처리량(TPS)     | 쿠폰 발급 API의 동시 처리량                 | 1,000 TPS 이상     |
| 처리량(TPS)     | 주문 생성 API의 동시 처리량                 | 500 TPS 이상       |

**성능 최적화 전략**
- Redis 캐싱을 통한 조회 성능 향상
- 인덱스 최적화로 쿼리 성능 개선
- 커넥션 풀 최적화

---

### 2. 신뢰성 (Reliability)

| 항목        | 요구사항                                                           |
|-----------|-----------------------------------------------------------------|
| 데이터 정합성   | 동시성 제어가 필요한 작업(재고 차감, 포인트 사용, 쿠폰 발급)에서 데이터 정합성을 보장해야 한다.        |
| 트랜잭션 일관성  | 주문 및 결제 프로세스에서 ACID 속성을 만족하는 트랜잭션 일관성을 유지해야 한다.                |
| 장애 복구     | 시스템 장애 발생 시 데이터 손실 없이 복구 가능해야 한다.                              |
| 감사 추적     | 포인트 변경, 쿠폰 발급/사용, 주문 상태 변경 등 중요 이벤트를 이력으로 기록해야 한다.            |

**신뢰성 보장 방법**
- 낙관적 락/비관적 락을 통한 동시성 제어
- 트랜잭션 격리 수준 설정 (READ_COMMITTED 이상)
- 중요 데이터의 이력 테이블 유지

---

### 3. 확장성 (Scalability)

| 항목      | 요구사항                                       |
|---------|-----------------------------------------------|
| 수평 확장   | 애플리케이션 서버는 수평 확장이 가능해야 한다.                 |
| 데이터베이스  | 읽기/쓰기 분리(Read/Write Splitting)를 고려한 설계    |
| 메시지 큐   | Kafka 등의 메시지 큐를 통한 비동기 처리가 가능해야 한다.        |
| 캐시      | Redis 캐시를 활용한 부하 분산                        |

**확장성 고려사항**
- Stateless 애플리케이션 설계 (세션은 Redis에 저장)
- MSA 전환을 고려한 도메인 분리 설계
- 데이터베이스 샤딩 고려 (향후)

---

### 4. 가용성 (Availability)

| 항목           | 요구사항                       | 목표치       |
|--------------|----------------------------|-----------|
| 시스템 가용성      | 연간 시스템 가동률                 | 99.9% 이상  |
| 장애 감지 시간     | 장애 발생 시 감지 시간              | 1분 이내     |
| 복구 시간        | 장애 발생 시 서비스 복구 시간          | 10분 이내    |

---

### 5. 보안 (Security)

| 항목          | 요구사항                                   |
|-------------|----------------------------------------|
| 인증          | JWT 또는 세션 기반 인증 적용                    |
| 비밀번호 암호화    | BCrypt 등 단방향 해시 알고리즘 사용              |
| API 보안      | 인증된 사용자만 자신의 데이터에 접근 가능 (인가 처리)      |
| SQL Injection | Prepared Statement 사용으로 SQL Injection 방지 |

---

### 6. 유지보수성 (Maintainability)

| 항목       | 요구사항                                 |
|----------|--------------------------------------|
| 코드 가독성   | 클린 코드 원칙 준수, 명확한 네이밍              |
| 테스트 커버리지 | 단위 테스트 커버리지 70% 이상                 |
| 로깅       | 주요 비즈니스 로직의 실행 과정 로깅              |
| 모니터링     | 애플리케이션 메트릭 수집 및 대시보드 구성 (선택사항)   |

---

## 제약사항 및 가정

### 제약사항

1. **외부 결제 연동 제외**
   - 실제 PG사 연동 없이 포인트로만 결제
   - 실제 금융 거래는 발생하지 않음

2. **회원가입 기능 간소화**
   - 별도의 회원가입 UI 없이 DB에 직접 데이터 생성
   - 이메일 인증, 본인 인증 등 제외

3. **알림 기능 제외**
   - 주문 완료, 배송 알림 등은 구현하지 않음
   - 이벤트 발행까지만 구현 (선택사항)

4. **배송 기능 제외**
   - 주문 완료 후 배송 처리는 범위 외

### 가정사항

1. **트래픽 규모**
   - 동시 접속자: 최대 10,000명
   - 일일 주문 건수: 최대 100,000건
   - 선착순 쿠폰 발급: 동시 요청 10,000건 이상

2. **데이터 규모**
   - 상품 수: 약 10,000개
   - 회원 수: 약 1,000,000명
   - 주문 데이터: 연간 약 3,000만 건

3. **운영 환경**
   - 애플리케이션 서버: 최소 2대 이상 (로드 밸런싱)
   - 데이터베이스: MySQL 8.0 이상
   - 캐시: Redis 6.0 이상
   - 메시지 큐: Kafka 3.0 이상 (선택사항)

